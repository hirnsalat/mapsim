<!DOCTYPE html>
<script type="module">

// import kaboom lib
import kaboom from "./kaboom.mjs";

// initialize kaboom context
kaboom({
    crisp : false,
    letterbox : true,
    width : 640,
    height : 480,
});

// load shit
loadSprite("lich", "HORUS-LICH.png")

// globals
let curDraggin = null
let justStartedDraggin = true
let curScale = 1
let camDragStartWorld = null
let camDragStartScreen = null
let hexTop = 1
let hexRight = Vec2.fromAngle(30).x
let hexRightUp = Vec2.fromAngle(30).y

// A custom component for handling drag & drop behavior
function drag() {

    // The displacement between object pos and mouse pos
    let offset = vec2(0)

    return {
        // Name of the component
        id: "drag",
        // This component requires the "pos" and "area" component to work
        require: [ "pos", "area", ],
        // "add" is a lifecycle method gets called when the obj is added to scene
        add() {
            // TODO: these need to be checked in reverse order
            // "this" in all methods refer to the obj
            this.onClick(() => {
                if (curDraggin) {
                    return
                }
                curDraggin = this
                offset = toWorld(mousePos()).sub(this.pos)
                // Remove the object and re-add it, so it'll be drawn on top
                readd(this)
            })
        },
        // "update" is a lifecycle method gets called every frame the obj is in scene
        update() {
            if (curDraggin === this) {
                // cursor("move")
                this.pos = toWorld(mousePos()).sub(offset)
            }
        },
    }

}

function slot() {
    return {
        add() {
            // TODO: these need to be checked in reverse order
            // "this" in all methods refer to the obj
            this.onClick(() => {
                if (curDraggin != null && ! justStartedDraggin) {
                    curDraggin.pos = this.pos
                    curDraggin = null
                }
            })
        },
    }
}

function hexWidth(r) {
    return r * hexRight * 2
}

function hex(r) {
    let w = hexWidth(r)
    return {
        width : w,
        height : r*2,
        draw() {
            drawPolygon({
                //pos: this.pos,
                pts: [
                    Vec2.fromAngle(30).scale(r),
                    Vec2.fromAngle(90).scale(r),
                    Vec2.fromAngle(150).scale(r),
                    Vec2.fromAngle(210).scale(r),
                    Vec2.fromAngle(270).scale(r),
                    Vec2.fromAngle(330).scale(r),
                ],
                //color: rgb(w(128, 255, 8), 255, w(128, 255, 4)),
                outline: {
                    width: 1,
                    color: rgb(0, 0, 0),
                },
            })
        },
    }
}

function hexX(x, y, r) {
    if(y % 2) {
        x += 0.5
    }
    return hexWidth(r) * x
}
function hexY(x, y, r) {
    return (hexRightUp*r + r)*y
}

function hexgrid(hexw, hexh, h, w) {
    let shiftx = hexw
    let shifty = hexh * 3/4
    let hexpts = [
            vec2(0,-hexh/2),
            vec2(hexw/2, -hexh/4),
            vec2(hexw/2, hexh/4),
            vec2(0, hexh/2),
            vec2(-hexw/2, hexh/4),
            vec2(-hexw/2, -hexh/4),
        ]
    let side1points = [
            vec2(0, hexh/2),
            vec2(-hexw/2, hexh/4),
            vec2(-hexw/2, hexh/2),
            vec2(0, hexh/2 + hexh/4),
        ]
    let side2points = [
            vec2(hexw/2, hexh/4),
            vec2(0, hexh/2),
            vec2(0, hexh/2 + hexh/4),
            vec2(hexw/2, hexh/2),
        ]
    let outline = {
            width: 1,
            color: rgb(0, 0, 0),
        }

    let colors = []
    let shades1 = []
    let shades2 = []
    for(let i = 0; i < h*w; i++) {
        let hue = rand()
        colors[i] = hsl2rgb(hue,0.2,0.9)
        shades1[i] = hsl2rgb(hue,0.2,0.6)
        shades2[i] = hsl2rgb(hue,0.2,0.7)
    }
    let shifts = []
    for(let i = 0; i < h*w; i++) {
        shifts[i] = randi(hexh/8)
    }

    return {
        draw() {
            let border = vec2(hexw,hexh)
            let screenRect = new Rect(toWorld(vec2(0,0).sub(border)), toWorld(vec2(width(),height()).add(border)))
            let firstX = Math.max(Math.floor(toWorld(vec2(0,0)).x / shiftx), 0)
            let firstY = Math.max(Math.floor(toWorld(vec2(0,0)).y / shifty), 0)
            let lastX = Math.min(Math.ceil(toWorld(vec2(width(),height())).x / shiftx), w-1)
            let lastY = Math.min(Math.ceil(toWorld(vec2(width(),height())).y / shifty), h-1)

            for(let y = firstY; y <= lastY; y++) {
                for(let x = firstX; x <= lastX; x++) {
                    let shift = wave(0,hexh/8,time() + shifts[x+y*w])
                    let hexpos = vec2(shiftx*(x + (y%2)*0.5),shifty*y + shift)
                    drawPolygon({
                        pos : hexpos,
                        pts : side1points,
                        outline,
                        color: shades1[x+y*w],
                    })
                    drawPolygon({
                        pos : hexpos,
                        pts : side2points,
                        outline,
                        color: shades2[x+y*w],
                    })
                    drawPolygon({
                        pos : hexpos,
                        pts : hexpts,
                        outline,
                        color: colors[x+y*w],
                    })
                }
            }

        }
    }
}

// toggle fullscreen mode on "f"
onKeyPress("f", (c) => {
    fullscreen(!isFullscreen())
})

onMouseRelease((mousePos) => {
    justStartedDraggin = curDraggin == null
})

camScale(curScale);

//// doesn't work, don't know why
// onMousePress("forward", () => {
//     curScale += 0.5;
//     camScale(curScale);
// })

onMousePress("middle", () => {
    camDragStartWorld = mousePos()
    camDragStartScreen = camPos()
})

onMouseDown("middle", () => {
    let newMousePos = mousePos()
    let worldOffset = newMousePos.sub(camDragStartWorld).scale(1 / curScale) //.scale(camScale())
    camPos(camDragStartScreen.sub(worldOffset))
})

layers([
    "map",
    "objects",
])

//add([
//    sprite("lich"),
//    area(),
//    drag(),
//    scale(0.2),
//    pos(60, 160),
////    origin("bot"),
//    origin(vec2(0,0.75)),
//    layer("objects"),
//    hidden(),
//]);

add([
    hexgrid(80,80, 100, 100),
    layer("map"),
    scale(1, 1),
]);


//for(let x = 0; x < 10; x++) {
//    for(let y = 0; y < 10; y++) {
//        add([
//            //rect(50,40),
//            hex(20),
//            area(),
//            outline(1),
//            slot(),
//            scale(1,1),
//            pos(100 + hexX(x,y,20),40 + hexY(x,y,20)),
//            origin("center"),
//        ]);
//    }
//}
camPos(400, 400);

</script>
