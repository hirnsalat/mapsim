<!DOCTYPE html>
<script type="module">

// import kaboom lib
import kaboom from "./kaboom.mjs";

// initialize kaboom context
kaboom({
    crisp : false,
    letterbox : true,
    width : 640,
    height : 480,
});

// load shit
loadSprite("lich", "HORUS-LICH.png")

// globals
let curDraggin = null
let justStartedDraggin = true
let curScale = 1
let camDragStartWorld = null
let camDragStartScreen = null
let hexTop = 1
let hexRight = Vec2.fromAngle(30).x
let hexRightUp = Vec2.fromAngle(30).y

// A custom component for handling drag & drop behavior
function drag() {

    // The displacement between object pos and mouse pos
    let offset = vec2(0)

    return {
        // Name of the component
        id: "drag",
        // This component requires the "pos" and "area" component to work
        require: [ "pos", "area", ],
        // "add" is a lifecycle method gets called when the obj is added to scene
        add() {
            // TODO: these need to be checked in reverse order
            // "this" in all methods refer to the obj
            this.onClick(() => {
                if (curDraggin) {
                    return
                }
                curDraggin = this
                offset = toWorld(mousePos()).sub(this.pos)
                // Remove the object and re-add it, so it'll be drawn on top
                readd(this)
            })
        },
        // "update" is a lifecycle method gets called every frame the obj is in scene
        update() {
            if (curDraggin === this) {
                // cursor("move")
                this.pos = toWorld(mousePos()).sub(offset)
            }
        },
    }

}

function slot() {
    return {
        add() {
            // TODO: these need to be checked in reverse order
            // "this" in all methods refer to the obj
            this.onClick(() => {
                if (curDraggin != null && ! justStartedDraggin) {
                    curDraggin.pos = this.pos
                    curDraggin = null
                }
            })
        },
    }
}

function hexWidth(r) {
    return r * hexRight * 2
}

function hexX(x, y, r) {
    if(y % 2) {
        x += 0.5
    }
    return hexWidth(r) * x
}
function hexY(x, y, r) {
    return (hexRightUp*r + r)*y
}

function hexToIndex(q, r) {
    let s = -q-r
    let dist = Math.max(Math.abs(q), Math.abs(r), Math.abs(s))
    let distOffset = 1+ 3 * dist * (dist-1)

    if(dist == 0) return 0

    if(q == dist) {
        return distOffset -s
    } else if(s == -dist) {
        return distOffset + dist + r
    } else if(r == dist) {
        return distOffset + 2*dist -q
    } else if(q == -dist) {
        return distOffset + 3*dist +s
    } else if(s == dist) {
        return distOffset + 4*dist -r
    } else if(r == -dist) {
        return distOffset + 5*dist +q
    }
}

function hexgrid(hexw, hexh, h, w) {
    let shiftx = hexw
    let shifty = hexh * 3/4
    let hexpts = [
            vec2(0,-hexh/2),
            vec2(hexw/2, -hexh/4),
            vec2(hexw/2, hexh/4),
            vec2(0, hexh/2),
            vec2(-hexw/2, hexh/4),
            vec2(-hexw/2, -hexh/4),
        ]
    let side1points = [
            vec2(0, hexh/2),
            vec2(-hexw/2, hexh/4),
            vec2(-hexw/2, hexh/2),
            vec2(0, hexh/2 + hexh/4),
        ]
    let side2points = [
            vec2(hexw/2, hexh/4),
            vec2(0, hexh/2),
            vec2(0, hexh/2 + hexh/4),
            vec2(hexw/2, hexh/2),
        ]
    let outline = {
            width: 1,
            color: rgb(0, 0, 0),
        }

    let inithex = () => {
        let hue = rand()

        return {
            color :  hsl2rgb(hue,0.2,0.9),
            shade1 : hsl2rgb(hue,0.2,0.6),
            shade2 : hsl2rgb(hue,0.2,0.7),
            shift :  randi(hexh/8),
            //name : hexToIndex(x - Math.floor(y/2), y),
        }
    }

    let drawhex = (x, y, hex) => {
        let shift = wave(0,hexh/8,time() + hex.shift)
        let hexpos = vec2(shiftx*(x + (y%2)*0.5),shifty*y + shift)
        drawPolygon({
            pos : hexpos,
            pts : side1points,
            outline,
            color: hex.shade1,
        })
        drawPolygon({
            pos : hexpos,
            pts : side2points,
            outline,
            color: hex.shade2,
        })
        drawPolygon({
            pos : hexpos,
            pts : hexpts,
            outline,
            color: hex.color,
        })
        //drawText({
        //    pos : hexpos,
        //    text : hex.name,
        //    size : 30,
        //    origin : "center",
        //})
    }

    let hexes = []
    for(let i = 0; i < h*w; i++) {
        hexes[i] = inithex()
    }


    return {
        draw() {
            let border = vec2(hexw,hexh)
            let screenRect = new Rect(toWorld(vec2(0,0).sub(border)), toWorld(vec2(width(),height()).add(border)))
            let firstX = Math.max(Math.floor(toWorld(vec2(0,0)).x / shiftx), 0)
            let firstY = Math.max(Math.floor(toWorld(vec2(0,0)).y / shifty), 0)
            let lastX = Math.min(Math.ceil(toWorld(vec2(width(),height())).x / shiftx), w-1)
            let lastY = Math.min(Math.ceil(toWorld(vec2(width(),height())).y / shifty), h-1)

            for(let y = firstY; y <= lastY; y++) {
                for(let x = firstX; x <= lastX; x++) {
                    drawhex(x, y, hexes[x+y*w])
                }
            }

        }
    }
}

//// fullscreen mode breaks mouse :(
//// toggle fullscreen mode on "f"
//onKeyPress("f", (c) => {
//    fullscreen(!isFullscreen())
//})

onMouseRelease((mousePos) => {
    justStartedDraggin = curDraggin == null
})

camScale(curScale);

//// doesn't work, don't know why
// onMousePress("forward", () => {
//     curScale += 0.5;
//     camScale(curScale);
// })

onMousePress("middle", () => {
    camDragStartWorld = mousePos()
    camDragStartScreen = camPos()
})

onMouseDown("middle", () => {
    let newMousePos = mousePos()
    let worldOffset = newMousePos.sub(camDragStartWorld).scale(1 / curScale) //.scale(camScale())
    camPos(camDragStartScreen.sub(worldOffset))
})

layers([
    "map",
    "objects",
])

let infotext = add([
    layer("objects"),
    pos(0, 0),
    fixed(),
    text("hi"),
]);


onMouseMove((mousePos) => {
    mousePos = toWorld(mousePos)
    let fr = mousePos.y / 60 // hexh * 3/4
    let fq = mousePos.x / 80 - fr / 2 // hexh
    let fs = -fq - fr

    let q = Math.round(fq)
    let r = Math.round(fr)
    let s = Math.round(fs)

    let q_diff = Math.abs(q - fq)
    let r_diff = Math.abs(r - fr)
    let s_diff = Math.abs(s - fs)

    if (q_diff > r_diff && q_diff > s_diff) {
        q = -r-s
    } else if (r_diff > s_diff) {
        r = -q-s
    } else {
        s = -q-r
    }

    infotext.text = q + "," + r + "," + s + ":" + hexToIndex(q,r)
})

//add([
//    sprite("lich"),
//    area(),
//    drag(),
//    scale(0.2),
//    pos(60, 160),
////    origin("bot"),
//    origin(vec2(0,0.75)),
//    layer("objects"),
//    hidden(),
//]);

add([
    hexgrid(80,80, 100, 100),
    layer("map"),
]);

camPos(0, 0);

</script>
